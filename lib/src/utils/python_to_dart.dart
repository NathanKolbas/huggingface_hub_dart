// This file contains utils for python code written to work in dart

import 'dart:io' show File, FileSystemException, FileSystemEntity, FileSystemEntityType, Link;

import 'package:dio/dio.dart';
import 'package:flutter/foundation.dart';
import 'package:path/path.dart' as p;

/// Finds the longest common path from a list of absolute paths.
///
/// This function is the Dart equivalent of Python's `os.path.commonpath`.
/// It correctly handles different path separators for Windows, Linux, and macOS.
///
/// [paths] A list of absolute paths to compare.
///
/// Returns the common path as a string. If the list is empty or there is
/// no common path (e.g., different drives on Windows), it returns an
/// empty string.
///
/// Created with Gemini 2.5 pro
String? commonPath(List<String> paths) {
  if (paths.isEmpty) return null;

  // Split all paths into their individual components.
  // e.g., "/home/user/docs" -> ["/", "home", "user", "docs"]
  final List<List<String>> allParts = paths.map((path) => p.split(path)).toList();

  // Find the path with the fewest components to set the loop boundary.
  List<String> shortestPath = allParts.reduce((a, b) => a.length < b.length ? a : b);

  final commonParts = <String>[];

  for (int i = 0; i < shortestPath.length; i++) {
    // Get the component to check from the first path.
    final String currentPart = allParts[0][i];

    // Check if this component is the same in all other paths.
    for (int j = 1; j < allParts.length; j++) {
      if (allParts[j][i] != currentPart) {
        // Mismatch found, the common path is what we have so far.
        return p.joinAll(commonParts);
      }
    }

    // All paths have this part in common, add it to our list.
    commonParts.add(currentPart);
  }

  // If we get here, the shortest path is a common prefix for all paths.
  return p.joinAll(commonParts);
}

/// A helper function to parse an HTTP `Link` header.
///
/// The `requests` library does this automatically, but in Dart we must do it manually.
/// This simplified parser extracts URLs based on their `rel` attribute.
///
/// Example Header: `<url1>; rel="rel1", <url2>; rel="rel2"`
///
/// Returns a map of `rel` values to their corresponding URLs.
///
/// Generated by Gemini 2.5 Pro
Map<String, String> parseLinkHeader(String? headerValue) {
  if (headerValue == null || headerValue.isEmpty) return {};

  final links = <String, String>{};
  final entries = headerValue.split(',');

  final urlRegex = RegExp(r'<(.*?)>');
  final relRegex = RegExp(r'rel="?([^"]+)"?');

  for (final entry in entries) {
    final parts = entry.split(';');
    if (parts.isEmpty) continue;

    final urlMatch = urlRegex.firstMatch(parts[0]);
    if (urlMatch == null) continue;

    final url = urlMatch.group(1)!;
    String? rel;

    for (final param in parts.skip(1)) {
      final relMatch = relRegex.firstMatch(param.trim());
      if (relMatch != null) {
        rel = relMatch.group(1);
        break;
      }
    }

    if (rel != null) {
      links[rel] = url;
    }
  }
  return links;
}

/// Move a file from [src] path to [dst] path
Future<File> moveFile(String src, String dst) async {
  File newFile;
  final srcFile = File(src);
  try {
    // First try to move the file
    newFile = await srcFile.rename(dst);
  } on FileSystemException catch (e) {
    // On some platforms, a rename operation cannot move a file between different file systems.
    // If that is the case, we copy the file to the new location and then remove the original.
    newFile = await srcFile.copy(dst);
    await srcFile.delete();
  }
  return newFile;
}

/// Copy a file from [src] path to [dst] path.
/// Takes into account where the [src] is a symlink as Dart is not able to copy
/// symlinks on Windows due to a bug.
Future<File> copyFle(String src, String dst, { bool recursive = false }) async {
  if (await FileSystemEntity.isLink(src)) {
    // Windows can't copy symlinks due to a bug in dart
    // On Linux and MacOS (Unix) it will copy the target file and not the symlink
    // This handles that actually creating the symlink at the dst
    final String linkTarget = await Link(src).resolveSymbolicLinks();
    await Link(dst).create(linkTarget, recursive: recursive);
    return File(dst);
  }

  if (recursive) {
   await File(dst).parent.create(recursive: recursive);
  }
  return await File(src).copy(dst);
}

/// Ge the unix timestamp which is equivalent to python's `time.time()`.
/// Returns seconds since epoch e.g. "1753339377.418567".
///
/// On web the precision is slightly reduced due to the max of 53 bits.
double unixTimestamp([DateTime? timestamp]) {
  timestamp ??= DateTime.now();

  if (kIsWeb) {
    return timestamp.millisecondsSinceEpoch / 1_000;
  }

  return timestamp.microsecondsSinceEpoch / 1_000_000;
}

/// In python the requests package allows you to raise the error at a later point.
/// This helper function helps with that. Probably should be more robust...
Future<(Response, void Function())> raiseForStatusDioWrapper(Future<Response> Function() requestFn) async {
  Response? response;
  void Function() raiseForStatus = () {};
  try {
    response = await requestFn();
  } on DioException catch (e) {
    response = e.response;
    raiseForStatus = () => throw e;
  }
  return (response!, raiseForStatus);
}

/// Converts a shell-style wildcard pattern into a valid RegExp pattern.
///
/// Generated by Gemini 2.5 Pro.
RegExp fnmatchToRegExp(String pattern) {
  // 1. Escape all special RegExp characters.
  String escaped = RegExp.escape(pattern);

  // 2. Convert fnmatch wildcards to RegExp wildcards.
  //    - `*` (fnmatch) becomes `.*` (RegExp)
  //    - `?` (fnmatch) becomes `.` (RegExp)
  String withWildcards = escaped.replaceAll(r'\*', '.*').replaceAll(r'\?', '.');

  // 3. Anchor the pattern to match the entire string.
  return RegExp('^$withWildcards\$');
}
